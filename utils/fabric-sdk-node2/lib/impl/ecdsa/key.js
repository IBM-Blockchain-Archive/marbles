/*
 Copyright 2016 IBM All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

	  http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

'use strict';

var Ber = require('asn1').Ber;
var Hash = require('../../hash.js');
var jsrsa = require('jsrsasign');
var asn1 = jsrsa.asn1;
var KEYUTIL = jsrsa.KEYUTIL;
var ECDSA = jsrsa.ECDSA;

/*
 * This module implements the {@link module:api.Key} interface, for ECDSA.
 * @module ECDSA_KEY
 */
module.exports = class ECDSA_KEY {
	/*
	 * this class represents the private key of an ECDSA key pair.
	 *
	 * @param {Object} key This must be the "privKeyObj" part of the object generated by KEYUTIL.generateKeypair()
	 */
	constructor(key, keySize) {
		if (typeof key === 'undefined' || key === null) {
			throw new Error('The publicKey parameter is required by this key class implementation, whether this instance is for the public key or private key');
		}

		if (typeof keySize === 'undefined') {
			throw new Error('The ECDSA Key class requires the key size');
		}

		if (keySize !== 256 && keySize !== 384) {
			throw new Error('The ECDSA Key class only supports key sizes 256 and 384');
		}

		this._keySize = keySize;
		this._key = (typeof key === 'undefined') ? null : key;
	}

	/**
	 * @returns {string} a string representation of the hash from a sequence based on the private key bytes
	 */
	getSKI() {
		var sk = new Ber.Writer();
		sk.startSequence();
		sk.writeInt(1);
		sk.writeBuffer(new Buffer(this._key.prvKeyHex, 'hex'), 4);
		sk.writeByte(160);
		sk.writeByte(7);
		if (this._keySize === 384) {
			// OID of P384
			sk.writeOID('1.3.132.0.34');
		} else {
			// OID of P256
			sk.writeOID('1.2.840.10045.3.1.7');
		}

		sk.endSequence();

		if (this._keySize === 256) {
			return Hash.sha3_256(sk.buffer);
		} else {
			return Hash.sha3_384(sk.buffer);
		}
	}

	isSymmetric() {
		return false;
	}

	isPrivate() {
		if (typeof this._key.prvKeyHex !== 'undefined' && this._key.prvKeyHex === null)
			return false;
		else
			return true;
	}

	getPublicKey() {
		var f = new ECDSA({ curve: this._key.curveName });
		f.setPublicKeyHex(this._key.pubKeyHex);
		f.isPrivate = false;
		f.isPublic = true;
		return new ECDSA_KEY(f, this._keySize);
	}

	/**
	 * Generates a CSR/PKCS#10 certificate signing request for this key
	 * @param {string} subjectDN The X500Name for the certificate request in LDAP(RFC 2253) format
	 * @returns {string} PEM-encoded PKCS#10 certificate signing request
	 * @throws Will throw an error if this is not a private key
	 * @throws Will throw an error if CSR generation fails for any other reason
	 */
	generateCSR(subjectDN) {

		//check to see if this is a private key
		if (!this.isPrivate()){
			throw new Error('A CSR cannot be generated from a public key');
		};

		try {
			var csr = asn1.csr.CSRUtil.newCSRPEM({
				subject: { str: asn1.x509.X500Name.ldapToOneline(subjectDN)},
				sbjpubkey: this.getPublicKey()._key,
				sigalg: 'SHA256withECDSA',
				sbjprvkey: this._key
			});
			return csr;
		} catch (err) {
			throw err;
		}
	}

	toBytes() {
		// this is specific to the private key format generated by
		// npm module 'jsrsasign.KEYUTIL'
		if (this.isPrivate()) {
			throw new Error('This is a private key, dumping to bytes are not allowed');
		} else {
			return KEYUTIL.getPEM(this._key);
		}
	}
};